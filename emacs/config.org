#+TITLE: Emacs à la Mane
#+AUTHOR: Mane
#+DESCRIPTION: Konfigurationsdatei für Emacs.
* TABLE OF CONTENTS :toc:
- [[#ausgelagerte-skripte-module][Ausgelagerte Skripte "Module"]]
- [[#dashboard][Dashboard]]
- [[#denote][Denote]]
- [[#dired][Dired]]
- [[#erscheinungsbild][Erscheinungsbild]]
  - [[#highlight-todo][Highlight TODO]]
  - [[#modeline][Modeline]]
  - [[#schrift][Schrift]]
  - [[#theme][Theme]]
  - [[#transparenz][Transparenz]]
  - [[#zooming-inout][Zooming In/Out]]
- [[#eshell--vterm][Eshell & vterm]]
- [[#flycheck][Flycheck]]
- [[#git][Git]]
- [[#ivy-counsel-company-helm-ivy-orderless][Ivy, counsel, company, helm, ivy, orderless]]
- [[#neotree][Neotree]]
- [[#org][Org]]
  - [[#settings][Settings]]
  - [[#table-of-contents][Table of Contents]]
  - [[#org-bullets][Org Bullets]]
  - [[#source-code-block-tag-expansion][Source Code Block Tag Expansion]]
  - [[#transclusion][Transclusion]]
  - [[#presentationen][Presentationen]]
  - [[#roam][roam]]
- [[#safe-undo-redo-yank][Safe Undo Redo Yank]]
- [[#search][Search]]
- [[#which-key][Which-Key]]
- [[#workspaces][Workspaces]]

* Ausgelagerte Skripte "Module"
Die Teile der Konfiguration die ich wenig ändere und die ich als Skripte in Form einer .el Datei im Skriptordner ausgelagert habe kann ich hier rein laden mit dem folgenden Befehl -> so wird die Konfigurationsdatei hier nicht unnötig groß und bleibt übersichtlicher -> um etwas als script auszulagern einfach im Skript Ordner eine .el dazu erstellen und am Ende der .el ~(provide 'name-des-elisp-files)~ einfügen und hier dann auf den Ordner verweisen!
#+begin_src emacs-lisp
(add-to-list 'load-path "~/.config/emacs/scripts/")
(add-to-list 'load-path "~/.config/emacs/scripts/denote")
(require 'setup-settings-basics)  ;; The Elpaca Package Manager
;;(require 'buffer-move)   ;; Buffer-move for better window management
;;(require 'app-launcher) ;; Use emacs as a run launcher like rofi (experimental)
;; (require 'org-roam) ;; Use emacs as second brain
#+end_src
* Dashboard
- Ich brauche eine .org mit Links, einen minor mode für den ich keybindings vergeben kann und eine Zeile die den minor-mode aktiviert sobald die .org aufgerufen wird. Zudem ist es hilfreich wenn die Startseite im read only Modus ist um nicht ungewollte Veränderungen vorzunehmen.

#+begin_src emacs-lisp

(use-package olivetti
  :ensure t)

(setq initial-buffer-choice "~/.config/emacs/start.org")

(defun mane-start-mode-enable ()
  "Funktionen, die beim Aktivieren von mane-start-mode ausgeführt werden."
  (olivetti-mode 1)
  (setq olivetti-body-width 180)) ; Beispielwert für die Breite

(defun mane-start-mode-disable ()
  "Funktionen, die beim Deaktivieren von mane-start-mode ausgeführt werden."
  (olivetti-mode -1))

(define-minor-mode mane-start-mode
  "Ein eigener Minor Mode für personalisierte Startseite-Funktionen."
  :lighter " Mane-Start"
  :keymap (make-sparse-keymap)
  :global nil
  (if mane-start-mode
      (mane-start-mode-enable)
    (mane-start-mode-disable)))

;; Hinzufügen von Keybindings zu mane-start-mode unter Verwendung von evil
(with-eval-after-load 'evil
  (evil-define-key 'normal mane-start-mode-map ;Keys sind nur um mane-start-mode vergeben
    (kbd "o z") 'eshell
;; (kbd "0") '(lambda () (interactive) (org-agenda))
;; (kbd "1") '(lambda () (interactive) (cfw:open-org-calendar))
;; (kbd "2") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/home.org"))
;; (kbd "3") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/work.org"))
;; (kbd "4") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/chemie.org"))
;; (kbd "5") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/unterrichtsplanung-chemie.org"))
;; (kbd "6") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/sport.org"))
;; (kbd "7") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/20231003-unterrichtsplanung_sport.org"))
;; (kbd "8") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/nachhilfe.org"))
;; (kbd "9") '(lambda () (interactive) (find-file "~/cloud/life/"))
;; (kbd "f") '(lambda () (interactive) (find-file "~/flowmis-os/flowmis-os-install.org"))
;; (kbd "p") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/projekte.org"))
;; (kbd "b") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/bücher.org"))
;; (kbd "w") '(lambda () (interactive) (find-file "~/cloud/life/raum/.org/bildung.org"))
    (kbd "9") (lambda () (interactive) (find-file "~/cloud/life/")))
)

   (add-hook 'mane-start-mode-hook 'read-only-mode) ;read-only-mode disablen wenn ich etwas ändern will (C-x C-q).
   (provide 'mane-start-mode)
#+end_src
* Denote
Siehe: https://protesilaos.com/emacs/denote#h:f3bdac2c-4704-4a51-948c-a789a2589790
-> Installation: ~cd ~/.config/emacs/scripts/~ + ~git clone https://git.sr.ht/~protesilaos/denote denote~ + 
~(add-to-list 'load-path "~/.config/emacs/scripts/denote")~ bei ausgelagerter Skripte angeben und dann die folgenden Konfigurationen vornehmen (Update mit git pull):
- Wichtige Features:
  - [[https://www.youtube.com/watch?v=gMq-703ZVZQ][Sorting and org-dynamic-blocks]] für Meta Notes (siehe auch [[https://www.youtube.com/watch?v=zzXcav0yb50][hier]])
#+begin_src emacs-lisp
(require 'denote)
;; Remember to check the doc strings of those variables.
(setq denote-directory (expand-file-name "~/cloud/life/raum/pkb/"))
(setq denote-known-keywords '("klasse8" "klasse9" "klasse10" "chemie" "sport" "nwt" "crypt" "wissen" "fun" "work" "vb" "hb" "fb" "bb" "trendsport" "bag" "lsw" "tanzen"))
(setq denote-infer-keywords t)
(setq denote-sort-keywords t)
(setq denote-file-type nil) ; Org is the default, set others here
(setq denote-prompts '(title keywords))
(setq denote-excluded-directories-regexp nil)
(setq denote-excluded-keywords-regexp nil)

;; Pick dates, where relevant, with Org's advanced interface:
(setq denote-date-prompt-use-org-read-date t)


;; Read this manual for how to specify `denote-templates'.  We do not
;; include an example here to avoid potential confusion.


(setq denote-date-format nil) ; read doc string

;; By default, we do not show the context of links.  We just display
;; file names.  This provides a more informative view.
(setq denote-backlinks-show-context t)

#+end_src

* Dired
- <% m> mit regex markieren
- k (mit evil keybindings ist es K) um markiertes nicht mehr anzuzeigen und g (mit evil keybinds ist es revert buffer und das habe ich auf <SPC b r>) um wieder alles anzuzeigen
- t alles markieren was nicht markiert ist und alles was markiert ist nicht mehr markieren - dreht markiertes quasi um sodass leicht nur noch das gefundenen durch regex angezeigt wird bzw ausgeblendet wird.
- schönerers Dired mit weniger Details: <M-x dired-hide-details-mode>
- Mit <M-p> und <M-n> in der Historie hin und her bewegen bei find-file für dired
- In dired find-file kann man einfach einen vollständigen Pfad eingeben ~/... ohne zuvor dorthin zu gehen, oder bis dahin zu löschen -> man kann dort somit auch einfach einen fertigen Pfad hineinkopieren!
- Bei find-file muss man auch nicht den ganzen Pfad ausschreiben, sondern man kann ~/cl/lif/ra/p schreiben um zu /home/flowmis/cloud/life/raum/pkb/ zu gelangen.
- Mit ^ oder - kann man in dired eine Ebene nach oben und mit Enter öffnen oder eine Ebene tiefer -> Mit peep-dired geht es auch mit den evil vim keys!
- Mit <Shift Enter> kann man eine Datei in einem seperatem Window öffnen und den Fokus in dieses Window setzen (Je nach Schriftgröße wird Emacs horizontal/vertikal das Window spliten)
- Mit <Alt Enter> kann man eine Datein in einem seperatem Window öffnen ohne den Fokus in dieses Window zu setzen
- Mit O kann man den owner einer Datei ändern
- Mit R kann ich rename machen (ist zugleich Ausschneiden und Einfügen um eine Datei zu bewegen)
- M um den Mode einer Datei zu ändern um sie beispielsweise ausführbar zu machen (chmod)
- m und C und u unnd U und d und D und x sollten mir bewusst sein 
- Mit i kann ich in den insert-mode und Dateien umbenennen und das dann mit <C-c C-c> bestätigen/schreiben
- Mit + kann ich einen neuen Ordner hinzufügen, aber geht auch mit find-file um neue Ordner oder Dateien an einem Pfad zu erstellen
- Makros sind hier sehr mächtig um gleiche Aktionen mehrfach automatisiert durchführen zu können (Datei öffnen und Inhalt einfügen oder ändern und wieder zurück in dired, oder einfach nur um schnell viele Dateien auf bestimmte Art umzubenennen)
- Emacs ist clever wenn ich einen Split habe und etwas markiere und move oder copy ausführe es als Vorschlag direkt in den zweiten Buffer verschieben zu wollen

- Wenn ich einen Pfad in Emacs habe mit dem cursor auf dem Pfad bin und in fidn file gehe kann ich mit <M-n> den Pfad unter dem Cursor in find file einfügen
  
Anstatt ein weiteres Paket zu verwenden um Programme außerhalb Emacs mit einem bestimmten Programm zu öffnen (Beispielsweise die Pakete: open-with oder dired-open) kann ich mir auch Programme vorschlagen lassen (Öffnen mit !=synchron oder &=asynchron) -> Mit <M-n> und <M-p> kann ich zwischen den Vorschlägen wechseln.
#+begin_src emacs-lisp
(setq dired-guess-shell-alist-user
      '(("\\.\\(png\\|jpe?g\\|tiff\\)" "viewnior" "gimp" "xdg-open")  ;xdg-open heißt Standardprogramm verwenden
        ("\\.\\(mp[34]\\|m4a\\|ogg\\|flac\\|webm\\|mkv\\)" "vlc" "xdg-open")
		(".*" "xdg-open")))
(use-package dired-open
  :config
  (setq dired-open-extensions '(("gif" . "vlc")
                                ("pdf" . "zathura")
                                ("docx" . "onlyoffice-desktopeditors")
                                ("odt" . "onlyoffice-desktopeditors")
                                ("xlsx" . "onlyoffice-desktopeditors")
                                ("jpg" . "viewnior")
                                ("png" . "viewnior")
                                ("mkv" . "vlc")
                                ("mp4" . "vlc"))))
;; peep-dired aktivieren wenn ich live Vorschau von Bildern oder Textdateien aktivieren will, dann sehe ich wenn ich mit j und k in dired durch die Dateien scrolle im Split-View die entsprechende Vorschau zur Datei! (ist nicht immer aktiviert, da ich das nicht immer will und geht nur im normalen mode, also mehrmals ESC und dann nochmal aktivieren in dired mit meinem Keymap und dann sollte das mit der Vorschau gehen!)
(use-package peep-dired
  :after dired
  :hook (evil-normalize-keymaps . peep-dired-hook)
  :config
    (evil-define-key 'normal dired-mode-map (kbd "h") 'dired-up-directory)
    (evil-define-key 'normal dired-mode-map (kbd "l") 'dired-open-file) ; use dired-find-file instead if not using dired-open package
    (evil-define-key 'normal peep-dired-mode-map (kbd "j") 'peep-dired-next-file)
    (evil-define-key 'normal peep-dired-mode-map (kbd "k") 'peep-dired-prev-file)
)
;; (add-hook 'dired-mode-hook 'dired-hide-details-mode) ;wenn ich dired übersichtlicher haben mag kann ich es hier aktivieren
#+end_src
* Erscheinungsbild
** Highlight TODO
Adding highlights to TODO and related words.
#+begin_src emacs-lisp
(use-package hl-todo
  :hook ((org-mode . hl-todo-mode)
         (prog-mode . hl-todo-mode))
  :config
  (setq hl-todo-highlight-punctuation ":"
        hl-todo-keyword-faces
        `(("TODO"       warning bold)
          ("FIXME"      error bold)
          ("HACK"       font-lock-constant-face bold)
          ("REVIEW"     font-lock-keyword-face bold)
          ("NOTE"       success bold)
          ("DEPRECATED" font-lock-doc-face bold))))

#+end_src
** Modeline
Falls die Icons nicht richtig angezeigt werden muss ich <M-x nerd-icons-install-fonts> ausführen und neu starten - siehe auch: https://github.com/seagle0128/doom-modeline
#+begin_src emacs-lisp
(use-package doom-modeline
  :ensure t
  :init (doom-modeline-mode 1)
  :config
  (setq doom-modeline-height 25     ;sets modeline height
	    doom-modeline-bar-width 10  ;sets right bar width
        doom-modeline-persp-name t  ;adds perspective name to modeline
        doom-modeline-persp-icon t  ;adds folder icon next to persp name
	    display-time-day-and-date t
        display-time-24hr-format t)
  (display-time-mode 1)
)
#+end_src
** Schrift
#+begin_src emacs-lisp
(set-face-attribute 'default nil
  :font "JetBrains Mono"
  :height 110
  :weight 'medium)
(set-face-attribute 'variable-pitch nil
  :font "Ubuntu"
  :height 120
  :weight 'medium)
(set-face-attribute 'fixed-pitch nil
  :font "JetBrains Mono"
  :height 110
  :weight 'medium)
;; Makes commented text and keywords italics.
;; This is working in emacsclient but not emacs.
;; Your font must have an italic face available.
(set-face-attribute 'font-lock-comment-face nil
  :slant 'italic)
(set-face-attribute 'font-lock-keyword-face nil
  :slant 'italic)

;; This sets the default font on all graphical frames created after restarting Emacs.
;; Does the same thing as 'set-face-attribute default' above, but emacsclient fonts
;; are not right unless I also add this method of setting the default font.
(add-to-list 'default-frame-alist '(font . "JetBrains Mono-11"))

;; Uncomment the following line if line spacing needs adjusting.
(setq-default line-spacing 0.12)
#+end_src
** Theme
- Theme im [[https://emacsfodder.github.io/emacs-theme-editor/#theme-generated][Theme-Editor]] erstellen und die .el Datei dann als Theme in den ~/.config/emacs/theme Ordner speichern: https://github.com/emacsfodder/emacs-theme-editor
-> meine Themes: [[/home/flowmis/flowmis-os/tangle/themes/][hier]].
- Ich habe die Themes so angepasst, dass ich es einfach habe neue Farbparletten zu verwenden -> Farbpaletten erstellen [[https://coolors.co/414141-3e3e3e-7e7e7e-777777-828282][hier]]


#+begin_src emacs-lisp
  (add-to-list 'custom-theme-load-path "~/.config/emacs/themes/")

  (use-package doom-themes
    :config
    (setq doom-themes-enable-bold t    ; if nil, bold is universally disabled
	  doom-themes-enable-italic t) ; if nil, italics is universally disabled
    ;; (load-theme 'doom-one t)
    (load-theme 'mane-2 t)
    ;; Enable custom neotree theme (all-the-icons must be installed!)
    (doom-themes-neotree-config)
    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config))

  (defun load-theme-mane-1 ()
  "Lädt Theme mane-1"
  (interactive)
  (load-theme 'mane-1 t))

  (defun load-theme-mane-2 ()
  "Lädt Theme mane-2"
  (interactive)
  (load-theme 'mane-2 t))
#+end_src
** Transparenz
With Emacs version 29, true transparency has been added.
#+begin_src emacs-lisp
(add-to-list 'default-frame-alist '(alpha-background . 90)) ; For all new frames henceforth
#+end_src
** Zooming In/Out
#+begin_src emacs-lisp
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)
(global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
(global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)
#+end_src
* Eshell & vterm
- Eine Emacs 'shell' die in Elisp geschrieben ist.
- Vterm is a terminal emulator within Emacs.  The 'shell-file-name' setting sets the shell to be used in M-x shell, M-x term, M-x ansi-term and M-x vterm.  By default, the shell is set to 'fish' but could change it to 'bash' or 'zsh' if you prefer.
- [[https://github.com/jixiuf/vterm-toggle][vterm-toggle]] toggles between the vterm buffer and whatever buffer you are editing.

#+begin_src emacs-lisp
(use-package eshell-toggle
  :custom
  (eshell-toggle-size-fraction 3)
  (eshell-toggle-use-projectile-root t)
  (eshell-toggle-run-command nil)
  (eshell-toggle-init-function #'eshell-toggle-init-ansi-term))

(use-package eshell-syntax-highlighting
  :after esh-mode
  :config
  (eshell-syntax-highlighting-global-mode +1))

(setq eshell-rc-script (concat user-emacs-directory "eshell/profile")
      ;; eshell-rc-script "~/.config/emacs/eshell/profile"
      eshell-aliases-file (concat user-emacs-directory "eshell/aliases")
      ;; eshell-aliases-file "~/.config/emacs/eshell/aliases"
      eshell-history-size 5000
      eshell-buffer-maximum-lines 5000
      eshell-hist-ignoredups t
      eshell-scroll-to-bottom-on-input t
      eshell-destroy-buffer-when-process-dies t
      eshell-visual-commands'("bash" "fish" "htop" "ssh" "top" "zsh")
)

(use-package vterm
:config
(setq shell-file-name "/bin/sh"
      vterm-max-scrollback 5000))

(use-package vterm-toggle
  :after vterm
  :config
  (setq vterm-toggle-fullscreen-p nil)
  (setq vterm-toggle-scope 'project)
  (add-to-list 'display-buffer-alist
               '((lambda (buffer-or-name _)
                     (let ((buffer (get-buffer buffer-or-name)))
                       (with-current-buffer buffer
                         (or (equal major-mode 'vterm-mode)
                             (string-prefix-p vterm-buffer-name (buffer-name buffer))))))
                  (display-buffer-reuse-window display-buffer-at-bottom)
                  ;;(display-buffer-reuse-window display-buffer-in-direction)
                  ;;display-buffer-in-direction/direction/dedicated is added in emacs27
                  ;;(direction . bottom)
                  ;;(dedicated . t) ;dedicated is supported in emacs27
                  (reusable-frames . visible)
                  (window-height . 0.3))))
#+end_src

* Flycheck
Install python-pylint for flycheck to work with python files. For more information on language support for flycheck, [[https://www.flycheck.org/en/latest/languages.html][read this]].

#+begin_src emacs-lisp
(use-package flycheck
  :ensure t
  :defer t
  :init (global-flycheck-mode))
#+end_src

* Git
- [[https://github.com/emacsmirror/git-timemachine][git-timemachine]] ein Programm um einfach in der git Historie hin und her zu wechseln. 'SPC g t' open the time machine on a file if it is in a git repo. 'CTRL-j' and 'CTRL-k' to move backwards and forwards through the commits.
- [[https://magit.vc/manual/][Magit]] git client for Emacs.

#+begin_src emacs-lisp
(use-package git-timemachine
  :after git-timemachine
  :hook (evil-normalize-keymaps . git-timemachine-hook)
  :config
    (evil-define-key 'normal git-timemachine-mode-map (kbd "C-j") 'git-timemachine-show-previous-revision)
    (evil-define-key 'normal git-timemachine-mode-map (kbd "C-k") 'git-timemachine-show-next-revision)
)
(use-package magit)
#+end_src

* Ivy, counsel, company, helm, ivy, orderless
- Ivy, a generic completion mechanism for Emacs.
- Counsel, a collection of Ivy-enhanced versions of common Emacs commands.
- Ivy-rich allows us to add descriptions alongside the commands in M-x.
- [[https://company-mode.github.io/][Company]] is a text completion framework for Emacs. The name stands for "complete anything".  Completion will start automatically after you type a few letters. Use M-n and M-p to select, <return> to complete or <tab> to complete the common part.
- Helm und mein App-Launcher vertragen sich nicht sodass ich wenn ich hier helm aktiv hab die zusätzlichen beiden Funktionen + Änderungen zum deaktivieren und aktivieren über hooks während der Nutzung des App-Launchers benötige um alles funktionieren zu lassen -> siehe hierfür 

#+begin_src emacs-lisp
(use-package company
  :defer 2
  :custom
  (company-begin-commands '(self-insert-command))
  (company-idle-delay .1)
  (company-minimum-prefix-length 2)
  (company-show-numbers t)
  (company-tooltip-align-annotations 't)
  (global-company-mode t))

(use-package company-box
  :after company
  :hook (company-mode . company-box-mode))
#+end_src
#+begin_src emacs-lisp
(use-package counsel
  :after ivy
  :config (counsel-mode))

(use-package ivy
  :bind
  ;; ivy-resume resumes the last Ivy-based completion.
  (("C-c C-r" . ivy-resume)
   ("C-x B" . ivy-switch-buffer-other-window))
  :custom
  (setq ivy-use-virtual-buffers t)
  (setq ivy-count-format "(%d/%d) ")
  (setq enable-recursive-minibuffers t)
  :config
  (ivy-mode))

(use-package all-the-icons-ivy-rich
  :ensure t
  :init (all-the-icons-ivy-rich-mode 1))

(use-package orderless ;um mit M-x auch ohne die richtige Reihenfolge treffer für Funktionen zu erhalten hilft das Paket [[https://github.com/oantolin/orderless][orderless]].
  :ensure t
  :init
  (setq completion-styles '(orderless)
        completion-category-defaults nil
        completion-category-overrides '((file (styles . (partial-completion))))
	  orderless-component-separator "[ &]"))

(use-package helm ;orderless brauch helm dass es richtig funktioniert
  :ensure t
  :config
  (helm-mode 1))
(global-set-key (kbd "M-x") 'helm-M-x)

(use-package ivy-rich
  :after ivy
  :ensure t
  :init (ivy-rich-mode 1) ;; this gets us descriptions in M-x.
  :custom
  (ivy-virtual-abbreviate 'full
   ivy-rich-switch-buffer-align-virtual-buffer t
   ivy-rich-path-style 'abbrev)
  :config
  (ivy-set-display-transformer 'ivy-switch-buffer
                               'ivy-rich-switch-buffer-transformer))

#+end_src

* Neotree
#+begin_src emacs-lisp
(use-package neotree
  :config
  (setq neo-smart-open t
        neo-show-hidden-files t
        neo-window-width 30
        neo-window-fixed-size nil
        inhibit-compacting-font-caches t
        projectile-switch-project-action 'neotree-projectile-action) 
        ;; truncate long file names in neotree
        (add-hook 'neo-after-create-hook
           #'(lambda (_)
               (with-current-buffer (get-buffer neo-buffer-name)
                 (setq truncate-lines t)
                 (setq word-wrap nil)
                 (make-local-variable 'auto-hscroll-mode)
                 (setq auto-hscroll-mode nil)))))
;; show hidden files
#+end_src

* Org
** Settings
Bei den Einstellungen hier eventuell darauf achten ob es bei init ~:after org~, also nach dem Laden von org-mode initial gesetzt werden, oder ob es Teil der :config ist!
#+begin_src emacs-lisp
(setq org-directory "~/cloud/life/raum/pkm/"
      org-log-into-drawer 1                  ;Notes mit <C-c C-z> werden direkt in den Drawer :LOGBOOK: geschrieben wenn dieser vorhanden ist
      org-startup-folded 'show3levels        ;beim Start werden Header bis zum 3 Level angezeigt
      org-publish-use-timestamps-flag nil    ;exportiert alles - macht Export leichter nachzuvollziehen
      org-export-with-broken-links t         ;macht auch einen Export wenn nicht alles passt - sometimes better than nothing
      org-edit-src-content-indentation 0     ;set src block automatic indent to 0 instead of 2.
      ;; org-log-done 'time
      ;; delete-by-moving-to-trash t     ;oder 'move-file-to-trash t'??
      ;; trash-directory "~/.papierkorb/" ;muss den Ordner manuell erstellen in Windows? Wenn etwas aus diesem Ordner gelöscht wird geht es glaub in den Systemtrash - also dann nicht mehr mein Papierkorb
        ;; org-journal-dir "~/cloud/life/raum/.org/"
      ;; org-journal-date-format "%B %d, %Y (%A) "
      ;; org-journal-file-format "%Y-%m-%d.org"
      ;; org-tag-alist (quote ((:startgroup) ("@Work" . ?w) ("@Home" . ?h) ("@Projekt" . ?p) ("@Ökonomie" . ?o) ("@Gesundheit" . ?g)       ;@ macht es zu mutual exclusiv tags die weggehen wenn anderer tag eingestellt wird
                            ;; (:endgroup) ("noexport" . ?n) ("Mane" . ?M) ("Joana" . ?J) ("Schule" . ?S)))
      ;; org-capture-templates '(("1" "TODO" entry (file+headline "~/cloud/life/raum/.org/home.org" "Aufgaben")"** %? [/] \n %a")
                              ;; ("2" "Einkaufsliste" checkitem (file+headline "~/cloud/life/raum/.org/home.org" "Einkaufsliste"))
                              ;; ("3" "Wunschliste" checkitem (file+headline "~/cloud/life/raum/.org/home.org" "Wunschliste"))
                              ;; ("4" "Neue Abrechnung" table-line (file+headline "~/cloud/life/raum/.org/work.org" "Abrechnungen Jo"))
                              ;; ("a" "Appointment" entry (file  "~/cloud/life/raum/.org/gcal.org") "* %?\n\n%^T\n\n:PROPERTIES:\n\n:END:\n\n")
                              ;; ("j" "Daily Journal" entry (file+olp+datetree "~/cloud/life/raum/.org/home.org" "Journal") "* %^{Description}      Hinzugefügt am: %U      %^g\n%?"))))
)


(org-babel-do-load-languages
 'org-babel-load-languages
 '((shell . t))) ;; Make sure shell is enabled brauch ich um einen src-block mit sh ausführen zu können innerhalb emacs

;; The following prevents <> from auto-pairing when electric-pair-mode is on.
;; Otherwise, org-tempo is broken when you try to <s TAB...
(add-hook 'org-mode-hook (lambda ()
           (setq-local electric-pair-inhibit-predicate
                   `(lambda (c)
                  (if (char-equal c ?<) t (,electric-pair-inhibit-predicate c))))))
#+end_src
** Table of Contents
#+begin_src emacs-lisp
(use-package toc-org
    :commands toc-org-enable
    :init (add-hook 'org-mode-hook 'toc-org-enable))
#+end_src
** Org Bullets
Org-bullets gives us attractive bullets rather than asterisks.

#+begin_src emacs-lisp
(add-hook 'org-mode-hook 'org-indent-mode)
(use-package org-bullets)
(add-hook 'org-mode-hook (lambda () (org-bullets-mode 1)))
#+end_src

** Source Code Block Tag Expansion
Org-tempo ist kein eigenes Paket sondern ein Modul in org das man aktivieren kann um '<s' mit TAB zu einem source-block umzuwandeln. Weitere Möglichkeiten: Änderungen dann lieber mit yasnippets und dann kann ich den Teil hier eigentlich auch löschen!

| Typing the below + TAB | Expands to ...                          |
|------------------------+-----------------------------------------|
| <a                     | '#+BEGIN_EXPORT ascii' … '#+END_EXPORT  |
| <c                     | '#+BEGIN_CENTER' … '#+END_CENTER'       |
| <C                     | '#+BEGIN_COMMENT' … '#+END_COMMENT'     |
| <e                     | '#+BEGIN_EXAMPLE' … '#+END_EXAMPLE'     |
| <E                     | '#+BEGIN_EXPORT' … '#+END_EXPORT'       |
| <h                     | '#+BEGIN_EXPORT html' … '#+END_EXPORT'  |
| <l                     | '#+BEGIN_EXPORT latex' … '#+END_EXPORT' |
| <q                     | '#+BEGIN_QUOTE' … '#+END_QUOTE'         |
| <s                     | '#+BEGIN_SRC' … '#+END_SRC'             |
| <v                     | '#+BEGIN_VERSE' … '#+END_VERSE'         |

#+begin_src emacs-lisp 
(require 'org-tempo)
#+end_src
** Transclusion
#+begin_src emacs-lisp 
(use-package org-transclusion
  :after org)
#+end_src
** Presentationen
*** Latex
*** reveal
https://github.com/yjwen/org-reveal/
** roam
* Safe Undo Redo Yank
- Aktuell so konfiguriert, dass die Dateien im Papierkob meiner Cloud landen! Alternativ sollte ich es so konfigurieren, dass sie in ~/.local/share/files/ landen!
- Ich werde aktuell nicht mehr gefragt ob ich etwas speichern will, aber alle ungespeicherten Änderungen bleiben solange ich den daemon nicht kille mit ~killall emacs~ erhalten. Ich kann also einen neuen Client öffnen und dann speichern. Wenn ich Emacs mit <C-x C-c> schließe werde ich dank der Funktion hier auch gefragt ob ich etwas ungespeichertes speichern will. Sollte ich vergessen etwas zu speichern und den daemon killen, dann wird eine Backup Datei vom Autosafe erstellt wo die Änderungen noch enthalten sind, aber der ungespeicherte Fortschritt ist im nächsten Client dann nicht mehr sichtbar und kann dort somit später nicht noch gespeichert werden. Da ich es mir ganz gut angewöhnt habe wichtige Änderungen zu speichern ist es auf diese Art sinnvoll, da unbeabsichtigte Speicherprozesse nicht passieren, aber kann schon sein, dass dann mal was nicht gespeichert wird und es mir auch nicht auffällt!!! Eventuell bekomme ich es daher noch hin auch eine Nachfrage im Buffer zu erhalten, ob der Client geschlossen werden soll mit oder ohne zu speichern wenn ich den Client nicht mit <C-x C-c> sondern über Qtile schließe!
- Undo Tree vll nicht das geilste Werkzeug und Git zusammen mit autosafe und der git timemachine die bessere Version Control!
#+begin_src elisp
(defun confirm-save-buffers-then-kill-emacs ()
  "Fragt nach dem Speichern von Buffern, dann ob Emacs wirklich geschlossen werden soll."
  (interactive)
  (if (save-some-buffers nil t) ; Änderungen wurden gespeichert oder keine Änderungen vorhanden.
      (when (yes-or-no-p "Emacs wirklich schließen? ")
        (kill-emacs))
    (when (yes-or-no-p "Ungespeicherte Änderungen vorhanden. Emacs dennoch schließen? ")
      (kill-emacs))))

(setq confirm-kill-emacs 'confirm-save-buffers-then-kill-emacs)

(defun copy-current-path-to-clipboard ()
  "Kopiert den Pfad der im aktuellen Buffer geöffneten Datei oder des aktuellen Dired-Verzeichnisses in die Zwischenablage."
  (interactive)
  (let ((path (if (equal major-mode 'dired-mode)
                  (dired-current-directory)
                (buffer-file-name))))
    (if path
        (progn
          (kill-new path)
          (message "Kopiert: %s" path))
      (message "Kein Pfad verfügbar!"))))

;; (setq 
      ;; undo-tree-auto-save-history t
      ;; undo-tree-history-directory-alist '(("." . "~/cloud/life/zeit/papierkorb/undo-tree-history/"))
      ;; save-interprogram-paste-before-kill t                                                                   ;Speichert kopierte Inhalte ausserhalb Emacs in den kill ring und macht es leichter bei zwischenzeitlichem löschen innerhalb Emacs das kopierte doch einzufügen
;; )
#+end_src
* Search
Eine sehr vielfältige starke Suche in Emacs ist mit [[https://github.com/emacsorphanage/helm-swoop][helm-swoop]] möglich. Es kann auch hilfreich sein, die einfache in Emacs integrierte Suche i-search zu verwenden, oder swiper zu installieren und damit zu arbeiten bzw. helm+swiper um ähnliche Funktion zu dieser Suche zu erhalten. Ich lasse i-search (C-s) mal aktiv und überschreibe das Keybinding nicht sondern binde diese umfangreichere Suche auf ein eigenes Keybinding, sodass ich beides nutzen kann (siehe Keybindings).
Mit Imenu kann ich schnell Headings/Sections finden -> habe ein Keybinding gesetzt, da imenu in emacs bereits vorinstalliert ist, habe ich hier nur imenu-list installiert und auch dafür ein Keybinding unter <SPC s>. 
#+begin_src elisp
(use-package helm-swoop
  :ensure t
  ;; :bind (("C-s" . helm-swoop))
)

(use-package imenu-list
  :ensure t
  :bind ("C-'" . imenu-list-smart-toggle)
  :config
  (setq imenu-list-focus-after-activation t))
#+end_src
* Which-Key
Hilfe welche Keys ich als nächstes drücken kann bzw. welche Keybidings vergeben wurden.
#+begin_src emacs-lisp
(use-package which-key
  :init
    (which-key-mode 1)
  :config
  (setq which-key-side-window-location 'bottom
	  which-key-sort-order #'which-key-key-order
	  which-key-allow-imprecise-window-fit nil
	  which-key-sort-uppercase-first nil
	  which-key-add-column-padding 1
	  which-key-max-display-columns nil
	  which-key-min-display-lines 6
	  which-key-side-window-slot -10
	  which-key-side-window-max-height 0.25
	  which-key-idle-delay 0.8
	  which-key-max-description-length 25
	  which-key-allow-imprecise-window-fit nil
	  which-key-separator " → " ))
#+end_src

* Workspaces
Ich verwende [[https://github.com/alphapapa/burly.el][burly]], da es minimalisitsch, einfach und icht in Konflikt mit meinem App-Launcher ist. Alternative die leider meinen App-Launcher unnutzbar macht sodass ich (rofi oder cerebro nutzen müsste) ist [[https://github.com/nex3/perspective-el][perspective]]. Auch ein ähnliches Paket ist [[https://depp.brause.cc/eyebrowse/][eyebrowse]].
#+begin_src emacs-lisp
(use-package burly)
#+end_src
